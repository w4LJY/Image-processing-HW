# HW5
 
# 1.	2D-DFT
## (1).	寫出自己的DFT (DC點在正中央) 對rect256.raw, circle256.raw, square256.raw, square256_rotate.raw.並顯示其頻譜，討論結果 
傅立葉轉換的公式為 在考慮到DC點需位移乘上 ，因此整個公式變為 
但若直接使用這個公式for迴圈的次數會是 ，我的電腦需要跑18分鐘。因此我將方程式拆分為兩個一維來分別進行運算。
 
  
改用一維來做for迴圈次數降為 ，使原本將近20分鐘才能跑完的程式，現在幾秒鐘就能夠出來了。
要實作公式，要處理方程式中的實部與虛部，我使用尤拉公式，將 拆分為 ，得到傅立葉結果的實部與虛部後，平方相加開根號得到頻譜圖的像素強度值。  
最後出來的結果整張圖都是黑的，因此我用normalize處理圖像，方便對頻譜圖的觀察。
  
傅立葉後的頻譜圖，與原圖存在著對應關係。首先，傅立葉結果代表的是原圖像的高低頻變化，如果原圖是整張同一顏色的無變化，那傅立葉結果就只會有頻譜圖中心的直流dc分量有值，而隨著原圖的顏色變化越劇烈，高頻就會越多，頻譜圖結果也會往外擴散。
Rect256.raw這張圖來看的話，x方向的顏色變化沒有y方向的變化強，因此結果會像是躺著的直條圖。
Circle256.raw這張圖，每個方向的顏色變化都是一樣的，因此結果圖也是一個圓。
由square256.raw與square256_rotat.raw可以發現，隨著圖像的旋轉，對於顏色變化響應結果也會因為方向改變而改變，可以知道頻譜圖會隨著圖像旋轉而旋轉。但如果只是一般的位移，頻譜圖是不會發生改變的。
A.	Rect256.raw原圖與傅立葉後的頻譜圖
   

B.	circle256.raw原圖與傅立葉後的頻譜圖 
   

C.	square256.raw原圖與傅立葉後的頻譜圖 
   

D.	square256_rotate.raw原圖與傅立葉後的頻譜圖 
   




(2).	比較自己的方法與openCV的方法，並討論結果的不同
Sol. openCV的方法我參考自openCV官網上的FFT過程，一開始，為了提升傅立葉轉換的速度，擴充圖像的尺寸
 
接著建立實部與虛部merge後的圖像
 
進行快速傅立葉轉換
 
方便觀察可能會加上對比度增強
 
位移使DC點在圖像中心
 
 
最後進行歸一化
 


A.	Rect256.raw傅立葉結果
 
B.	circle256.raw傅立葉結果
 	
C.	square256.raw傅立葉結果
 
D.	square256_rotate.raw傅立葉結果
 

openCV與我自己的方法結果是差不多的，最大的差別在於運算時間。以rect256.raw這張圖的運算時間來比較。
A.	我的方法對rect256.raw的運算時間
12.57秒
B.	openCV對rect256.raw的運算時間
0.012秒
可以發現兩者的時間差約有1000倍，因此FFT對於改善傅立葉的速度還是非常有效的。
(3).	寫出自己的IDFT並將反傅立葉的結果圖與原圖進行比較，算出MSE與PSNR的值。
Sol. 反傅立葉的公式為 
同樣拆分為一維來加快速度，且要將DC位移值乘回去
 
 
最後在將實部與虛部根據尤拉公式還原成原圖。 
 
A.	Rect256.raw IDFT結果與和原圖的
 
MSE: 29.46
PSNR:33.44
B.	circle256.raw IDFT結果與和原圖的
 
MSE:0.027
PSNR:63.86
C.	square256.raw IDFT結果與和原圖的
 
MSE:35.48
PSNR:32.63
D.	square256_rotat.raw IDFT結果與和原圖的
 
MSE:21.35
PSNR:34.87
