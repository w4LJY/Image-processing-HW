# 目標物件動態模擬 & 動態背景

# 摘要

本專題包含三個部分，第一部分為目標物件動態模擬，第二部分為動態背景，第三部分為上述兩部分之整合，並建立簡單易懂的GUI介面，以利於使用者操作。


# 簡介

我們使用Tkinter建立GUI介面供使用者操作，GUI內包含三個部分：
* 第一部分首先我們使用GrabCut演算法將前景與背景分離，再利用Inpaint以及Exemplar-Based Image Inpainting演算法進行填補，並根據箭頭指向移動前景；
* 第二部份利用設置錨點選取區域，再以Watershed演算法進行分區，對每個分區對其進行仿射轉換，最後再以獨特的演算法進行淡化，實現動態背景的效果；
* 第三部分將前兩部分整合，使輸出影像同時具備目標物件動態模擬和動態背景功能。

# 提出方法
## 1. GUI

我們使用python內建的Tkinter建立GUI，功能包含從資料夾中選取圖片、將選取圖片顯示在右方視窗、可根據題號選擇相應功能的項目欄，以及能調整**目標物件動態模擬**中目標移動速度的拉條，如下圖所示。

![](https://i.imgur.com/QlbnUMI.jpg)

## 2.	目標物件動態模擬

首先使用滑鼠框選目標範圍，再畫箭頭表示物件移動的方向，對框選區域進行GrabCut函式將可能的前景從圖中分離出來，並使用Inpaint函式填補背景，其中，為避免切割不完全進而影響填補，在填補之前先對圖像進行膨脹，然後根據箭頭向量算出各方向的單位平移量和總移動次數，再利用仿射矩陣將前景物件移動並貼回填補後背景圖。下圖為第一部分流程圖。

![](https://i.imgur.com/Nmt3PWC.png)

### 2.1. GrabCut

在圖片中框選方框，方框外區域自動被認作背景，用高斯混合模型對背景和前景建模，基於與周邊像素顏色相似程度算出一個屬於前景或背景的概率，每個像素會與一個前景或背景節點連線。若節點之間屬於不同類別則會進行分割[參考](https://www.itread01.com/content/1545377615.html)。以下為示意圖。

![](https://i.imgur.com/RrCcJcF.png)

我們利用其將前景進行分離，產生出只有前景以及只有背景的圖像，如圖所示。

![](https://i.imgur.com/jSVY70n.png) ![](https://i.imgur.com/EgLUeyn.png)

![](https://i.imgur.com/jmweXvn.png) ![](https://i.imgur.com/OlQDXj8.png)


### 2.2.	Inpaint

給予圖像中要修復的區域。從該區域的邊界逐漸填充邊界中的所有內容。利用像素周圍的一個小鄰域進行修復。該像素由鄰居中所有已知像素的歸一化加權和代替。給予靠近邊界的法線和位於邊界輪廓上的像素更多的權重。一旦像素被修復，將快速移動到下一個最近的像素，確保首先修復已知像素附近的像素[參考](https://www.cnblogs.com/lfri/p/10618417.html )。下圖為填補結果。

![](https://i.imgur.com/uqKZppk.png) ![](https://i.imgur.com/y8Ya5Cl.png)

### 2.3.	Exemplar-Based Image Inpainting
Exemplar-Based Image Inpainting是以patch為單位進行修補，與inpaint最大的差異在於inpaint是以pixel為單位進行修補，其主要流程分為計算優先級、搜尋、複製三個部分[參考](https://ieeexplore.ieee.org/document/1211538)。



#### a.	計算優先級
為保持修補過後的圖像仍保有結構性，邊緣能夠連通，在修補順序上是會經過篩選的，而優先度主要考慮兩個因素：
* 周圍像素可信度高的將優先修補
* 優先修補梯度較大變化的區域

#### b.	搜索

根據紋理相似度對整張圖像的已知區域進行搜尋，找到最佳匹配的區塊

#### c. 複製

將搜索後找到的最佳匹配區塊複製到對應目標區域，並更新邊緣與像素可信度，從第一步開始修補下一塊區域，持續循環。

下圖為Exemplar-Based Image Inpainting示意圖。相較inpaint，Exemplar-Based Image Inpainting的效果更加自然。

![](https://i.imgur.com/xjzoQPI.png)

選擇patch時需注意，patch過小，效果接近inpaint；patch過大，修補後的痕跡過於明顯，如下圖所示，此外，Exemplar-Based Image Inpainting的複雜度遠高於inpaint，需花費大量時間，因此，GUI功能中仍以inpaint為主。

![](https://i.imgur.com/oFRCVhe.png)

![](https://i.imgur.com/v8zCKXX.png)

### 2.4.	物件移動

移動部分使用到仿射矩陣，在平移矩陣中所需要的參數分別是x與y方向的位移量，如下式

![](https://i.imgur.com/5mu5EG2.png)

根據fps和速度V可求得：

![](https://i.imgur.com/HG44EwL.png)

![](https://i.imgur.com/LY6VweP.png)

![](https://i.imgur.com/8DESCId.png)

![](https://i.imgur.com/Jsfs5m1.png)

總移動次數times為：

![](https://i.imgur.com/azQBaSJ.png)

為了模擬物件一邊移動一邊縮小的效果，也可加入尺度矩陣，且因縮小後仍須保持長寬比，只需要設定一個縮放倍率即可。

![](https://i.imgur.com/2dzdvUI.png)

## 3. 動態背景

首先使用滑鼠點選設置錨點，再畫箭頭表示背景移動的方向，接著使用Watershed函式找出各個箭頭所表示的區域，圖八為第二部分流程圖。

### 3.1.	Watershed

分水嶺算法是一種圖像區域分割法，藉由參考臨近像素間的相似性作為依據，從而將在空間位置上相近並且灰度值相近的像素點互相連接起來構成一個封閉輪廓，封閉性是分水嶺算法的一個重要特徵。根據markers的輪廓作注水點，對圖像上其他像素點根據分水嶺算法規則進行判斷，並對每個像素點的區域歸屬進行劃定，直到處理完圖像上所有像素點[參考](https://zhhant.hotbak.net/key/opencv%E5%88%86%E6%B0%B4%E5%B6%BA%E5%88%86%E5%89%B2.html )。下圖為分水嶺效果。

![](https://i.imgur.com/IpO2IGf.png)

![](https://i.imgur.com/Le91FQR.png)

### 3.2.	動態模擬

為了模擬流動的效果，我們發現兩種使圖像帶有流動效果的原因，分別是物體形變與淡化。
形變效果最常見的是放大與縮小，但圖片由始至終必須保持同一尺寸。因此我對同一個區塊通過仿射轉換同時執行壓縮與拉伸，便可確保圖像保持固定大小，如下圖所示。

![](https://i.imgur.com/mtZart0.png)

![](https://i.imgur.com/73EFzxZ.png)

![](https://i.imgur.com/fsuC7HT.png)

主要有三個參數可調整，分別是起始的變化分界，每一次變化的程度，與總共變化的次數。
接下來就是考慮方向性，為使背景如同箭頭方向流動，需將圖像分別進行水平壓縮拉伸與垂直壓縮拉伸，而壓縮拉伸的程度需要符合箭頭x、y方向的單位向量比例。

### 3.3.	淡化

此時已經能模擬出流動的效果，但是在每個循環開始前會有明顯段落感，且形變次數較大時效果較不自然，為了解決這些問題，加入了淡化效果，若純粹使用原圖和形變後圖像進行淡化，只能解決形變次數較大時的不自然感，循環開始時仍有段落感。因此我們將圖像往箭頭的反方向形變n+1張圖，n為總共變化的次數，將正向與反向的圖像根據圖十一的飽和度變化相加，既能使每次循環間更加連續，也使輸出結果更加自然。

![](https://i.imgur.com/z6nZhZV.png)

## 4. 結合目標物件動態模擬 & 動態背景

第三部分整合了第一部分與第二部分，整合過程中需要注意的是1,2題的fps並不相同，且總時長也不一樣。因此我們以project1中物件移動的fps=15為基準，去對應動態模擬的5fps，並且動態模擬會持續循環直到物件移動的指定位置。

# 實驗結果與比較
從第一部分的實驗結果可以看出，GrabCut和Inpaint的計算時間極短，但是當背景與前景顏色差異不明顯時，GrabCut可能無法完美的分離前景背景，從而影響之後填補背景以及移動前景的效果，而且當背景顏色雜亂時Inpaint填補可能會過於突兀，而若是使用Exemplar-Based Image Inpainting，雖然效果些許提升，但取而代之的是龐大的計算量，因此，為了維持效能，Inpaint是較佳的選擇。
　　
第二部分的淡化效果大幅減少動態背景接續的突兀感，可使得動態背景更加擬真。由於計算時間主要是由箭頭數量多寡來決定，且隨著箭頭數量增加，其區域分界也會更加明顯，因此，若是流動大部分皆為同方向的話，推薦設置少量箭頭即可。
　　
第三部分將兩者結合，可使影片同時具備動態模擬以及動態背景的功能，但計算時間也隨之增加。各影片的部分截圖以及計算時間請參考後面的附錄。

# 結論

我們的貢獻是建立出簡單易懂的GUI介面，可使使用者輕鬆上手，並且實現前景分割、背景填補、動態模擬、動態背景等功能，並藉由獨特的淡化效果使得動態背景達到相當擬真的程度。























